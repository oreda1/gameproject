ポリモーフィズム
継承したクラス群を親クラスとみなすことができる
Scene<|--TitkeScene
Scene<|--GamePlaySceneScene
Scene<|--TitkeScene

状態遷移:とある状態から、次の状態へ、特定の条件で遷移する

初期化リスト(初期化子)というのがあって
コンストラクタ(パラメータ):メンバ変数1(値),メンバ変数2(値)
と書くことでそれぞれのメンバ変数を初期化することができます。
この部分での初期化は、メンバ変数のアドレスと同時と
ため、const変数や、&参照などの初期化に使われます。

ここで注意点は親クラスのconstや&参照のメンバの初期化を子クラスで直接行うことは出来ない
→なので、初期化リストでは親クラスの引数付きコンストラクタを呼び出すことで、constや&参照の中身を決定します。
子クラスコンストラクタ():親クラスのコンストラクタ(引数)

シングルトンクラス(singleton)
→アプリケーション中に、そのクラスのインスタンスを生成することができなくなります。
それだけでは利用できなくなってしまうだけなので、インスタンスを作成し、そこにアクセスできるようにします。

static変数,static関数とは…
宣言した地点で、アドレスが確定しているものです
なので、staticメンバ関数はクラスオブジェクトが生成されてなくても
呼び出すことができますし、static変数は宣言した地点でアドレスが確定しているため。スコープを抜けても居座り続けますし、何度参照しても同じ
アドレスを見ている←グローバル変数と同じ

①Application::GetInstance()関数内のstatic偏す
②Application applicationの地点で、別の場所にメモリが確保され、そこにApplicationの実態が生成されている。
なのでApplication application=Application::GetInstance();
これは許してはいけません

ところが、実は見えない部分に「コピーコンストラクタ」という関数ができていて、そいつが勝手にpublic側に置かれているため、特に対処をしなければ
このコードは通っちゃうのです。

なので、これらを防止するためにApplicationクラス側では明示的にコピーコンストラクタを宣言して、これをprivateに置きます。
もっと徹底するなら,代入演算子オーバーロードもprivateに置きます。
さらに徹底するならこれらの関数の後ろに=delete

usingについて
「別名」の作成

例えば
std::undered_map<std::string,std::vector<Monster*>>
このような型を使わなきゃいけない時があります

using MonsterTable_t=std::unordererd_map<std::string,std::vector<Monster*>>;

MonsterTable_T monsterTable1;
MonsterTable_T monsterTable2;
MonsterTable_T monsterTable3;

メンバ関数ポインタの時にも役に立ちます。
class Monster{
   void (Monster::*updateFunc_)(Input&input);

};これ実はupdateFunc_がメンバ変数に当たるのですが分かりづらい。
そこで
class Monster{
   using UddateFunc_t=void(Monster::*)(Input&input);

   あとはusingがよく使われるのが
   using namespase　std;
   のように「いまから各関数の先頭にはstd::つけてるかもよ~」
   というルールうぃ作ったりもします。
}

★「using namespaseはヘッダでは書かないでください」
using namespaceの影響範囲は、using namespaceより下の行の全てであるため

#include"...h"
というのは実は、…hの内容をそのまま#includeの行にコピーしてるだけです。
このため、下手にヘッダ側でusing namespaceを行うと
想定外の影響範囲に




namespace myprogram{
   class Player{
   public:
    statuc Func();
   }
}
この中のFuncを呼び出したかったら
myprogram::Player::Func();
のように呼び出します。

シーン中の状態遷移(状態遷移の中の状態遷移)
　メンバ関数ポインタによる状態遷移をやってみましょう

メンバ関数ポインタとは何か:メンバ関数を指し示せるようなポインタ
★関数も実はアドレスを持っています。で、関数ポインタはそのアドレスを格納している変数です。
そのアドレスを「呼び出す」という事をすれば、関数が実行されます
実は関数というのは、特定のアドレスにジャンプすることを示しています。そのアドレスを格納するポインタを切り替えて行くことで、
実行される関数を切り替えることが出来ます。

要は今の更新関数を切り替えることで様々な状態を維持したり切り替えたりできます。
ただし、メンバ関数ポインタは文法がちょっとややこしいです。

①まず宣言:戻り値(クラス名::*ポインタ変数名)(引数);
②次に代入:ポインタ変数=&クラス名::状態関数名;
③最後に実行:(this->*ポインタ変数)(引数);

状態遷移にはいくつか方法があって
①Stateパターンで、現在実行中の関数を切り替える
②メンバ関数ポインタで、現在実行中の関数を切り替える
③これらでにっちもさっちも行かない場合にはswitch文でもなんでも使おう

4つのキャストについて
static_cast<型名>(元の変数):いわゆる普通のキャスト
float f=3.14f;
int oyoso=static_cast<int>(f);
dynamic_cast<型名>(元の変数):ポリモーフィズムを使ってる時に子クラスの型に変換する
変換できない場合はnullptrを返す。

static_castは、特にnullptrを返さずに、変換できちゃう
→不具合の温床になる
dynamic_castはアウトの時にnullptrを返すために変換出来ない場合はすぐに分かる。

10/20 
デザインパターン
①Singletonパターン
(一人っ子パターン)[EOF]
→そのアプリケーションの中で「実体」が一つしかない
という事を保証するクラス←シングルトンクラス
[実体がある]←そのオブジェクトのためにメモリを消費している
そのクラスのsizeof(Class)分だけメモリが使われる
実体=インスタンスともいいます

[型]と[実体]は違います。
型は単なるプログラム言語の約束事なので[概念]みたいなものです。
概念は、メモリを消費していません。これがメモリを消費して変数なりなんなりに割り当てられた時に「実体化」します。

int;//←メモリを消費していない(実体がない)
int a;//sizeof(int)だけメモリを確保して、それを変数aとして使う
//実体化している。aとして使える
int*p;//これはメモリはsizeof(int*)だけ消費しています。
//ただしintの実体はありません。これはintの実体のアドレスを
//格納できる変数を宣言し、アドレス格納体の実体がある状態
int*p=new int;//これはどこかのアドレスにsizeof(int)を確保して
//そのアドレスをpに代入している
//←intの実体がある

で、シングルトンクラスの実体は

そのためには
①使用者側にnewをさせない
②




このためにシングルトンクラスはコンストラクタをprivateにして
「外部からコンストラクトを呼び出せなくする」
クラスは自身のメモリを確保するときに自動でコンストラクタを
呼びます
class T;
T t;//メモリ確保
T*t=new T//メモリ確保

このメモリ確保というのは。どちらもコンストラクタを呼び出します。
C++ではクラス宣言やnewで実体化しようとする場合は　
T*t=(T*)malloc(sizeof(T));
★mallocというのはC言語の命令で単純にメモリを確保してアドレスを
返すだけの関数です。
要は、確保した後に内部で(見えないところで)、クラス名と同じ関数
つまりコンストラクタをコールしているわけです。


①コンストラクタはprivate
②staticインスタンスを返す関数はpublic
にして、外部からは②の関数を通してしかそのクラスの実体にアクセス
できないようにします。

で、static変数とstatic関数について
staticは(静的)という意味で、メモリ確保したらそこにい続ける
ローカル変数だろうが何だろうが同じアドレスを見続け、
スコープ外に出ても、メモリの内容を覚えれいる。
ローカルstatic変数はその変数のアドレスが同一なので、
どこからアクセスしても同じものと言えます←シングルトンの節約に
ちょうどいい性質。

staticメンバ関数:
通常のメンバ関数はクラスが実体化するまでは呼び出すことができません
ところが、staticメンバ関数は実行時に既にアドレスが確定して
いるため実体化されなくても呼び出すことができます

FuncAはCが実体化しない限りアドレスが確定しないので呼び出せない
C::FuncA()l//


class Singleton{
 private:
   //コンストラクタをprivateに入れることで勝手に実体化されるのを防ぐ
   Singleton();
 public:
    static Singleton&GetInstanse(){
       static Singleton instance;//ここで唯一の実体ができる
       return instance;
    }
 };
 こいつを使うには
 Singleton&single=Singleton::GetInstance();
 のようにして使います。このインスタンスは必ず1つのみ
 であることが保証されます
　Singleton single=Singleton::GetInstance();が通ってしまう


「コピーコンストラクタ」というのは、宣言時に右辺値に他の
実体を配置することで、右辺値と内容が同じものを新たに作る際に呼び出されるコンストラクタである。
なので、上の例では、GetInstance()で得られた実体をもとに新たなもの

コピーコンストラクタの宣言は
クラス名(const クラス名&);
になりますので、これをprivateに配置します。それにより
コピーとして宣言することもできなくなり、完全に実体が1つであることが保証されます

 シングルトンクラスは別名「お行儀の良いグローバル変数」

 ②Stateパターン
 クラスそのものを"差し替え可能な「状態」"として扱い
 状態から状態へ変化できるようにするパターン。
 状態から状態への遷移条件は各状態クラスが知っている
 今の地点ですでに「シーン切り替え」として使っています。

 まず、すべての状態の基底クラスになるクラスを作ります。
 (今回でいうとSceneクラス)
 あとは、各状態はSceneクラスから派生したクラスとして作ります
 (今回でいうとTitleSceneやGameOverSceneなど)
 で、これを所持する側は現在の状態を気にせずただSce 


 関数ポインタとは
 関数も変数と同じように「アドレス」があります。
 void Func();
 というのがあって
 Funcと言う名前は、この関数があるアドレスに対応している。
 実は関数呼び出しというのは、関数があるアドレスにジャンプさせてる
 ということです。
 余談ですが、実際にはジャンプの時に「戻ってくるべきアドレス」を
 伝えています(乗っけています)
 これがないと関数実行後にどこに戻っていいかわからなくなるからです
 で、この「戻る場所を乗っけてる」のがちょっと曲者です。

 つまり戻る場所をスタックに乗っけているため、呼び出すたびに
 スタックをちょっとずつ消費します。
 なので、
 void  Function(){
    Function();
 
 }
 というような「再帰関数」を作ると、コールのたびにスタックが
 消費されます。なので、再帰関数を作るときは気を付けないと
 「スタックオーバーフロー」を起こします。

 引数無し。戻り値無しの場合は
 void(*f)();
 のように宣言します。この場合fが関数ポインタです。
 f=Function;
 などのように。関数のアドレスを入れることができます
　
　void(*f)()[]={};
f[rand()%n]();
のような使い方をします。

ここまでは普通の関数ポインタです

「メンバ」


例えば、クラスMonsterの引数無し戻り値なし
関数ポインタを宣言する場合は
class Monster{
    void(Monster:*func_)();
}
などと書かなきゃいけません
戻り値(クラス名::*メンバ関数ポインタ名)(引数);

×func_=Monster::FadeUpdate;
〇func_=&Monster::FadeUpdate;

持ち物・持ち主の明示
(this->*func_)();
というような呼び出しになる。
なお、->*は一つの演算子である(メンバ関数ポインタ指定演算子)

usingというのは、「型の別名」として使うこともできます。

画像の合成　代表的なものとして
①アルファ合成(ただし0≦a≦1.0)
元の画像*(1-a)+後の画像*a
このようにa値で線形補間する
②乗算合成
元の画像*後の画像
RGB値を(0~1,0~1,0~1)と考えます。
元画像を(sr,sg,sb)で後画像を(dr,dg,db)とすると
画素値は(sr*dr,sg*dg,sb*:dg)となります。
0~1ということは、乗算すればするほど
原則的には暗くなります。
(0.5,0.5,0.5)*(0.5,0.5,0.5)=(0.25,0.25,0.25)
(1.0,0.0,0.0)*(0.0,1.0,0.0)=(0.0,0.0,0.0)
DxLibのMULAは、後画像に対してa合成をしている
(sr,sg,sb)*((0,0,0)*a+(1,1,1)(1-a))
③加算合成
元画像＋後画像
(sr,sg,sb)+(dr,dg,db)=(sr+dr,sg+dg,sb+db);

 SetDrawBlendModeについて…
 使うと以降全ての描画が影響を受けるので
 SetDrawBlendMode(noblend,0)をして何もしない状態に戻す

 SetDrawBlendMode(DX_ALPHA,value);
 value*RGB+(1-value)*既に書かれている画像となります。

 ...mul
 ...mula
 これは既に描画されている内容に、この後のDraw画像で
 乗算合成をする。
 



 生ポインタを使わないようにしよう
 自分でnewやdeleteをしなくても自動的にできるものを
 スマートポインタと言う。

 ①shared_ptr:だれも監視しなくなったら消滅する
 ②weak_ptr:所有権を持っていません。なので、こいつが見ていてもこいつ以外の参照がすべてなくなれば
 解放される。ただし「生きているか死んでいるか」の判別ができる
 ③unique_ptr:一つしか存在しないポインタ

 使い方
 shared_ptr<型名>pointer;
 のように宣言する。アドレスが分かっている場合は
 shared_ptr<型名>pointer(アドレス);
 のように宣言時に入れることもできるし、後から
 pointer.reset(アドレス)
 というのもできる。

 状態遷移の拡張


 スマートポインタ

 スマートポインタとは、deleteを自動でやってくれる仕組み
 (テンプレートの仕組みにより自動で解放される)
 例えば、shared_ptr<Monster>monster(new Monster);
  で、このmonsterは変数としては「値型」ですが
  内部に元の生ポインタを持っていて、適切な時に開放する
  値型なので、もちろんスコープを外れると解放されますし
  誰かの持ち主の場合、持ち主が解放されると同時に解放される

  スマートポインタはこの仕組みをもっと強力にしたもの
　で、ほかのスマートポインタに代入されたりした場合には
参照カウンタがインクリメントされます。

ここまでが前提で、持ち主のshared_ptrがスコープを外れたり
=nullptrだとか、ほかのポインタを指し示す

weak_ptrは「参照カウントを上げないスマートポインタ」
shared_ptrを代入できる
shared_ptrの内部の参照カウンタを内部的に参照として持っていて、監視します

shared_ptr同士で代入=操作を行うと参照カウントは上がります


 
unique_ptrとは
これは「持ち主が1人だけのスマートポインタ」です。
→代入すると
基本的に参照カウントがあるとすると、

基底クラスはそれそのものでは存在できない
vector<Monster>monsters;
なんて宣言すると、
monsters.resize(100);
などと書いた場合、Monsterの実体を作ろうとして


monsters.erase(it);
monsters.pop_back();//末尾の要素を削除
monsters.pop_front();

次は、シーンをスタック構造にして、ポーズやポーズ先のメニューを
作れるようにしたいかなと思います。

このために次の時間は
list<Scene>
を使っていきます。

「シーンをスタック構造で管理する」
シーンをSceneという基底クラスから派生して、それを切り替えるという
「Stateパターン」を用いて管理しています。
これをもう一段階拡張して、特定のシーンに他の特定のシーンを
積んでいけるようにします。

今回は先ほども予告しましたがlistというのを使っていきます。
listはvectorのように、動的配列のように使えますし、ほぼほぼ
操作も一緒です。

違いは、内部的なメモリの扱い方にあります。
vectorは「メモリが連続していることを保証」します
listは「メモリは連続していませんが、追加と削除のコストが安い」

今回は

コンテナ(listやvector)において
backというのは、末尾を示します
frontというのは、先頭を示します。

push_front:先頭に追加
pop_back:末尾を削除
pop_front:先頭を削除
front():先頭の要素への参照を取得
back():末尾の要素への参照を取得



}

スマートポインタというのは、ポインタのふりをする

shared_ptr<ポインタとして扱いたい型>p;
のように宣言します。

これでpはポインタのように働いてくれます。

p->●●
でメンバを使える

*pでそのアドレスの値を取得できます。
これを実現しているのは内部でopereatorオーバーロードしてるからです

で、内部に「参照カウンタ」を持っているため、だれも持ち主が
いなくなった地点で元のポインタが保持するメモリの内容は解放されます。

通常　T*p=new T(引数)
shared_ptr<T>p=make_shared<T>(引数);
Sceneのポインタをshared_ptrに変更しました。

ポリモーフィズムを利用する場面ではポインタはつきものですが
そこでshared_ptrを使いましょう

shared_ptrを使っておけば、ポインタをlistやvectorの中に格納
している場合でも

先頭:push_front
末尾:push_back


今回のシーン構造の場合、ステータス更新と描画の関数を分けています。
「皆さんが作るゲームはパッド対応してほしい
よくあるのが、キーボードしか対応してません。ですが、
遊ぶ側としては、パッドに対応してほしいと思います



GetJoypPadInputState
を使って取得しますが、この中の
DX_INPUT_KEY_PAD1
はあまり使わないでほしい
これを使うとキーボードとパッドが固定される


パッドの種類にはいろいろある
PS系のパッド
XBox系のパッド


UnrealEngineは入力を直接見ているのではなく
「入力」と「ゲーム中の意味」の対応表


「std::map」です。
mapというのは「連想配列」です。
連想配列とは普通の配列をindex型に出来る

std::map<string int>pets;
pets["いぬ"]=5;
pets["猫"]=3;
pets["ウサギ"]=2;
pets["ペンギン"]=4;

cout<<GetValue(pets,"いぬ")<<endl;

pr.first="動物";
pr.second=15;

要は内部にfirstと、secondという要素を持っていて、それぞれ
別の型で管理されているのを1つにまとめているだけの型です。

何故この話をしたのかというと、std::mapというのは
std::pairの集合体

mapの場合はその中にあるpairのfirstがキーとなっていて、
データがsecondに当たります。

なので一覧を取得したい場合は
map<string,int>table;
データを入れていく

※注意
ハムスターを定義してない状態で
int a=table["ハムスター"];
とやると、クラッシュせずに、何事もなかったかのように
table["ハムスター"]=0;となってしまう


int GetValue(const std::map<std::string,int)&table,const char*str){
return table[str];
}
この関数はエラーを起こします

std::vector<int>a={1,3,5,7,9};
auto it=a.begin(); 最初の要素のイテレータを返す

ここでitは最初の要素の「位置」を指し示しています。
なのえ、中身を知りたければ

cout<<*it<<endl;
と書く必要があります。

この場合 a.end()は末尾の要素のお尻を指し示しています。
なので、*a.end()などと書いても値がないため、クラッシュします。

vectorやmapにはat(添え字)という関数があります。
table.at("ハムスター");
は。一応const性を守ってくれますが、ない要素を与えられるとassertを起こします

at(index)自体は[index]と同じ意味ですが、[ない要素]を入れるとクラッシュする関数です。
























